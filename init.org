#+TITLE: Emacs configuration file
#+AUTHOR: Johan Bay
#+PROPERTY: header-args :tangle yes
* init.el template
  #+BEGIN_SRC emacs-lisp :tangle no
    ;; This file replaces itself with the actual configuration at first run.

    ;; We can't tangle without org!
    (require 'org)
    ;; Open the configuration
    (find-file (concat user-emacs-directory "init.org"))
    ;; tangle it
    (org-babel-tangle)
    ;; load it
    (load-file (concat user-emacs-directory "init.el"))
    ;; finally byte-compile it
    (byte-compile-file (concat user-emacs-directory "init.el"))
  #+END_SRC
* Package repositories
#+BEGIN_SRC emacs-lisp
(require 'package)

(unless (assoc-default "melpa" package-archives)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t))

(package-initialize)
#+END_SRC
* Use package
[[https://github.com/jwiegley/use-package/blob/master/README.md]]
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile
  (require 'use-package))
(require 'diminish)                ;; if you use :diminish
(require 'bind-key)                ;; if you use any :bind variant

(setq use-package-always-ensure t)
#+END_SRC
* General settings
** Frame and font size
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(height . 47))
  (add-to-list 'default-frame-alist '(width . 110))
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-fontset-font "fontset-default" '(#x1d4d0 . #x1d4e2) "Symbola")
  (set-face-attribute 'default nil :family "Go Mono" :height 140)
#+END_SRC
** Disable eye-candy
#+BEGIN_SRC emacs-lisp
(scroll-bar-mode -1)
(tool-bar-mode -1)
(setq ring-bell-function 'ignore)
(setq inhibit-startup-screen t)
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Disable weird 2. selection
#+BEGIN_SRC
(global-unset-key (kbd "<M-drag-mouse-1>"))   ; was mouse-set-secondary
(global-unset-key (kbd "<M-down-mouse-1>"))   ; was mouse-drag-secondary
(global-unset-key (kbd "<M-mouse-1>"))    ; was mouse-start-secondary
(global-unset-key (kbd "<M-mouse-2>"))    ; was mouse-yank-secondary
(global-unset-key (kbd "<M-mouse-3>"))    ; was mouse-secondary-save-then-kill
#+END_SRC
** Time
#+BEGIN_SRC emacs-lisp
(setq-default
 display-time 1
 display-time-24hr-format t
 display-time-day-and-date nil
 display-time-default-load-average nil
 battery−mode−line−format " [%L %p%% %dC]")
(display-time-mode)
#+END_SRC
** Autosaves and Backup
#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t))
        save-place-file (concat user-emacs-directory "places")
        backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
  (setq backup-by-copying t)
  (setq delete-old-versions t
    kept-new-versions 6
    kept-old-versions 2
    version-control t)
#+END_SRC
** Enable global clipboard
#+BEGIN_SRC emacs-lisp
(setq
x-select-enable-clipboard t
x-select-enable-primary t)
#+END_SRC
** Uniquify
Make all buffers have unique names
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+END_SRC
** Mode line
#+BEGIN_SRC emacs-lisp
(line-number-mode t)
(column-number-mode t)
;(size-indication-mode t)
#+END_SRC
** macOS specific settings
#+BEGIN_SRC emacs-lisp
(setq mac-command-modifier 'meta)
(setq mac-option-modifier nil)
(setq locate-command "mdfind")
(setq ns-pop-up-frames nil)
;; Some mac-bindings interfere with Emacs bindings.
(when (boundp 'mac-pass-command-to-system)
(setq mac-pass-command-to-system nil))
#+END_SRC
** Dictionary
#+BEGIN_SRC emacs-lisp
(setenv "DICTIONARY" "en_GB")
(setq ispell-local-dictionary "english")
(setq ispell-local-dictionary-alist
      '(("english"     "[A-Za-z]" "[^A-Za-z]" "[']"       t ("-d" "en_GB") nil utf-8)
        ("american"    "[A-Za-z]" "[^A-Za-z]" "[']"       t ("-d" "en_US") nil utf-8)
        ("dansk"       "[A-Za-zÆØÅæøå]" "[^A-Za-zÆØÅæøå]" "[']" t ("-d" "da_DK") nil utf-8)))
(setq ispell-program-name "hunspell")
(defun fd-switch-dictionary()
  (interactive)
  (let* ((dic ispell-current-dictionary)
         (change (if (string= dic "english") "dansk" "english")))
    (ispell-change-dictionary change)
    (message "Dictionary switched from %s to %s" dic change)
    ))
(global-set-key (kbd "<f9>")   'fd-switch-dictionary)
#+END_SRC
** Scrolling
*** Preserve more lines
#+BEGIN_SRC emacs-lisp
(setq next-screen-context-lines 8)
#+END_SRC
** Misc
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-this-buffer)
  (global-set-key (kbd "C-x C-b") 'bury-buffer)

  (setq tramp-default-method "ssh")
  (setq explicit-shell-file-name "/bin/bash")

  (setq-default indent-tabs-mode nil)

  (setq-default fill-column 80)
  (setq-default sentence-end-double-space nil)
  (setq paragraph-start "\f\\|[ \t]*$\\|[ \t]*[-+*] ")

  (add-to-list 'ignored-local-variables 'preview-scale-function)

  (setq custom-safe-themes t)

  (show-paren-mode)

  (setq recenter-positions '(middle top bottom))

  (setq browse-url-browser-function 'eww-browse-url)
#+END_SRC
** Comments
Add bullets to comment blocks
#+BEGIN_SRC emacs-lisp
(setq paragraph-start "\f\\|[ \t]*$\\|[ \t]*[-+*] ")
#+END_SRC
Fix comment-dwim such that whole line is (un)commented when no region is active
#+BEGIN_SRC emacs-lisp
(defun xah-comment-dwim ()
  "Like `comment-dwim', but toggle comment if cursor is not at end of line.

URL `http://ergoemacs.org/emacs/emacs_toggle_comment_by_line.html'
Version 2016-10-25"
  (interactive)
  (if (region-active-p)
      (comment-dwim nil)
    (let ((-lbp (line-beginning-position))
          (-lep (line-end-position)))
      (if (eq -lbp -lep)
          (progn
            (comment-dwim nil))
        (if (eq (point) -lep)
            (progn
              (comment-dwim nil))
          (progn
            (comment-or-uncomment-region -lbp -lep)
            (forward-line )))))))

(global-set-key (kbd "M-;") 'xah-comment-dwim)
(global-set-key (kbd "C-æ") 'xah-comment-dwim)
#+END_SRC
* Crux
#+BEGIN_SRC emacs-lisp
  (use-package crux
    :bind* (("C-c o"   . crux-open-with)
            ("C-c e"   . crux-eval-and-replace)
            ("C-c C-t"   . eshell-command)
            ("C-c t" . eshell)
            ("C-^"     . crux-top-join-line)
            ("C-c d"   . crux-duplicate-current-line-or-region)
            ("C-a"     . crux-move-beginning-of-line))
    :config
    (setq pcomplete-ignore-case t))
#+END_SRC
* Undo tree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :bind (("C-x u" . undo-tree-visualize)
         ("C--" . undo))
  :config
  (global-undo-tree-mode))
#+END_SRC
* Rainbow Delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :config
    (rainbow-delimiters-mode-enable))
#+END_SRC
* Autorevert
#+BEGIN_SRC emacs-lisp
(use-package autorevert
  :diminish auto-revert-mode
  :config
  (global-auto-revert-mode 1))
#+END_SRC
* Discover my major
#+BEGIN_SRC emacs-lisp
(use-package discover-my-major
  :bind ("C-h C-m" . discover-my-major))
#+END_SRC
* Popwin
#+BEGIN_SRC emacs-lisp
(use-package popwin
  :config
  (global-set-key (kbd "C-z") popwin:keymap)
  (add-to-list 'popwin:special-display-config `("*Swoop*" :height 0.5 :position bottom))
  (add-to-list 'popwin:special-display-config `("*\.\* output*" :height 0.5 :noselect t :position bottom))
  (add-to-list 'popwin:special-display-config `("*Warnings*" :height 0.5 :noselect t))
  (add-to-list 'popwin:special-display-config `("*TeX Help*" :height 0.5 :noselect t))
  (add-to-list 'popwin:special-display-config `("*ENSIME Welcome*" :height 0.5 :noselect t))
  (add-to-list 'popwin:special-display-config `("*Procces List*" :height 0.5))
  (add-to-list 'popwin:special-display-config `("*Messages*" :height 0.5 :noselect t))
  (add-to-list 'popwin:special-display-config `("*Help*" :height 0.5 :noselect nil))
  (add-to-list 'popwin:special-display-config `("*Backtrace*" :height 0.5))
  (add-to-list 'popwin:special-display-config `("*Compile-Log*" :height 0.5 :noselect t))
  (add-to-list 'popwin:special-display-config `("*Remember*" :height 0.5))
  (add-to-list 'popwin:special-display-config `("*ansi-term*" :height 0.5 :position top))
  (add-to-list 'popwin:special-display-config `("*All*" :height 0.5))
  (add-to-list 'popwin:special-display-config `("*Go Test*" :height 0.3))
  ;(add-to-list 'popwin:special-display-config `("*undo-tree*" :width 0.3 :position right))
  (add-to-list 'popwin:special-display-config `("*Slack -" :regexp t :height 0.5 :position bottom))
  (add-to-list 'popwin:special-display-config `(flycheck-error-list-mode :height 0.5 :regexp t :position bottom))
  (popwin-mode 1))
#+END_SRC
* Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t
    :bind
    (
     ("C-M-k" . hydra-pause-resume)
     ("C-c C-h" . hydra-proof-general/body)
     ("C-x o" . hydra-window/body)
     ("C-c C-m" . hydra-multiple-cursors/body)
     ("C-c C-v" . hydra-toggle-simple/body)
     ("C-x SPC" . hydra-rectangle/body)
     ("C-c h" . hydra-apropos/body)
     :map Buffer-menu-mode-map
     ("h" . hydra-buffer-menu/body)
     :map org-mode-map
     ("C-c C-," . hydra-ox/body)
     )
    :config
    (defhydra hydra-zoom (global-map "<f2>")
      "zoom"
      ("g" text-scale-increase "in")
      ("l" text-scale-decrease "out"))
    (require 'hydra-examples)
    (require 'hydra-ox)
    (defhydra hydra-toggle-simple (:color blue)
      "toggle"
      ("a" abbrev-mode "abbrev")
      ("d" toggle-debug-on-error "debug")
      ("f" auto-fill-mode "fill")
      ("t" toggle-truncate-lines "truncate")
      ("w" whitespace-mode "whitespace")
      ("q" nil "cancel"))

    (defhydra hydra-yasnippet (:color blue :hint nil)
      "
                ^YASnippets^
  --------------------------------------------
    Modes:    Load/Visit:    Actions:

   _g_lobal  _d_irectory    _i_nsert
   _m_inor   _f_ile         _t_ryout
   _e_xtra   _l_ist         _n_ew
           _a_ll
  "
      ("d" yas-load-directory)
      ("e" yas-activate-extra-mode)
      ("i" yas-insert-snippet)
      ("f" yas-visit-snippet-file :color blue)
      ("n" yas-new-snippet)
      ("t" yas-tryout-snippet)
      ("l" yas-describe-tables)
      ("g" yas/global-mode)
      ("m" yas/minor-mode)
      ("a" yas-reload-all))

    (defhydra hydra-window (:color red
                                   :hint nil)
      "
   Split: _v_ert  _x_:horz
  Delete: _o_nly (_i_: ace)  _da_ce  _dw_indow  _db_uffer  _df_rame
    Move: _s_wap  _t_ranspose  _b_uffer
  Frames: _f_rame new  _df_ delete
  Resize: _h_:left  _j_:down  _k_:up  _l_:right
    Misc: _a_ce  a_c_e  _u_ndo  _r_edo"
      ;; ("h" windmove-left)
      ;; ("j" windmove-down)
      ;; ("k" windmove-up)
      ;; ("l" windmove-right)
      ("h" hydra-move-splitter-left)
      ("j" hydra-move-splitter-down)
      ("k" hydra-move-splitter-up)
      ("l" hydra-move-splitter-right)
      ("|" (lambda ()
             (interactive)
             (split-window-right)
             (windmove-right)))
      ("_" (lambda ()
             (interactive)
             (split-window-below)
             (windmove-down)))
      ("v" split-window-right)
      ("x" split-window-below)
      ("t" transpose-frame)
      ;; winner-mode must be enabled
      ("u" winner-undo)
      ("r" winner-redo) ;;Fixme, not working?
      ("o" delete-other-windows :exit t)
      ("i" ace-maximize-window :color blue)
      ("a" ace-window :exit t)
      ("c" ace-window)
      ("f" new-frame :exit t)
      ("s" ace-swap-window)
      ("b" ivy-switch-buffer)
      ("da" ace-delete-window)
      ("dw" delete-window)
      ("db" kill-this-buffer)
      ("df" delete-frame :exit t)
      ("q" nil)
                                          ;("m" headlong-bookmark-jump)
      )

    (defhydra hydra-multiple-cursors (:hint nil)
      "
       ^Up^            ^Down^        ^Other^
  ----------------------------------------------
  [_p_]   Next    [_n_]   Next    [_e_] Edit lines
  [_P_]   Skip    [_N_]   Skip    [_a_] Mark all
  [_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
  ^ ^             ^ ^             [_l_] Recenter
  "
      ("e" mc/edit-lines :exit t)
      ("l" recenter-top-bottom)
      ("a" mc/mark-all-like-this :exit t)
      ("n" mc/mark-next-like-this)
      ("N" mc/skip-to-next-like-this)
      ("M-n" mc/unmark-next-like-this)
      ("p" mc/mark-previous-like-this)
      ("P" mc/skip-to-previous-like-this)
      ("M-p" mc/unmark-previous-like-this)
      ("r" mc/mark-all-in-region-regexp :exit t)
      ("q" nil))

  (defhydra hydra-proof-general (:hint nil)
    "
  ^Assert^            ^Toggle^        ^Other^
  ----------------------------------------------
  [_n_]   Next    [_._]   Autosend    [_r_] Retract
  [_u_]   Undo    [_>_]   Electric    [_o_] Display
  [_b_]   Buffer  ^ ^                 [_l_] Layout
  "
      ("n" proof-assert-next-command-interactive)
      ("u" proof-undo-last-successful-command)
      ("b" proof-process-buffer :exit)
      ("." proof-electric-terminator-toggle)
      (">" proof-autosend-toggle)
      ("r" proof-retract-buffer)
      ("o" proof-display-some-buffers)
      ("l" proof-layout-windows))

  (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                       :color pink
                                       :post (deactivate-mark))
    "
  ^_k_^     _d_elete    _s_tring
  _h_   _l_   _o_k        _y_ank
  ^_j_^     _n_ew-copy  _r_eset
  ^^^^        _e_xchange  _u_ndo
  ^^^^        ^ ^         _p_aste
  "
    ("h" backward-char nil)
    ("l" forward-char nil)
    ("k" previous-line nil)
    ("j" next-line nil)
    ("e" exchange-point-and-mark nil)
    ("n" copy-rectangle-as-kill nil)
    ("d" delete-rectangle nil)
    ("r" (if (region-active-p)
             (deactivate-mark)
           (rectangle-mark-mode 1)) nil)
    ("y" yank-rectangle nil)
    ("u" undo nil)
    ("s" string-rectangle nil)
    ("p" kill-rectangle nil)
    ("o" nil nil)))
#+END_SRC
* Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind (("C-x g" . magit-status)))
#+END_SRC
* Diff hightlight
#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :config
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
  (global-diff-hl-mode))
#+END_SRC
* Execute path from shell
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :config
  (exec-path-from-shell-initialize)
  (setq exec-path-from-shell-check-startup-files nil)
  (exec-path-from-shell-copy-envs '("LANG" "GPG_AGENT_INFO" "SSH_AUTH_SOCK")))
#+END_SRC
* COMMENT God mode
#+BEGIN_SRC emacs-lisp
  (use-package god-mode
    :config
    (setq god-exempt-major-modes nil)
    (setq god-exempt-predicates nil)
    (defun my-update-look ()
      (if god-local-mode
          (global-hl-line-mode)
        (hl-line-unload-function)))
    (global-set-key (kbd "<escape>") 'god-mode-all)
    (define-key god-local-mode-map (kbd ".") 'repeat)
    (define-key god-local-mode-map (kbd "i") 'god-local-mode)
    (add-hook 'god-mode-enabled-hook 'my-update-look)
    (add-hook 'god-mode-disabled-hook 'my-update-look))
#+END_SRC
* Boon mode
#+BEGIN_SRC emacs-lisp
(use-package boon
    :config
    ;(require 'boon-colemak)
    (require 'boon-qwerty) ;; for qwerty port
    ;(require 'boon-powerline)
    ;(boon-powerline-theme) ;; if you want use powerline with Boon
    )
#+END_SRC
* OPAM
#+BEGIN_SRC emacs-lisp
(use-package opam
  :config
  (opam-init))
#+END_SRC
* Smex
#+BEGIN_SRC emacs-lisp
(use-package smex)
#+END_SRC
* Company mode
#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish company-mode
  :init
  ;; https://github.com/company-mode/company-mode/issues/50#issuecomment-33338334
  (defun add-pcomplete-to-capf ()
    (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
  :bind
  (("C-M-i" . company-complete)
   :map company-active-map
   ("C-n" . company-select-next)
   ("C-p" . company-select-previous))
  :config
  (setq company-idle-delay 0.2)
  (setq company-minimum-prefix-length 4)
  (global-company-mode))
#+END_SRC
* Expand region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  ("M-e" . er/expand-region))
#+END_SRC
* Multiple cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind
  (("C->" . mc/mark-next-like-this)
   ("C-<" . mc/mark-previous-like-this)
   ("C-c C-<" . mc/mark-all-like-this)
   ("M-<mouse-1>" . mc/add-cursor-on-click))
  :config)
#+END_SRC
* Which key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :config
  (which-key-mode)
  (which-key-setup-minibuffer)
  ;; (which-key-setup-side-window-right-bottom)
  (setq which-key-idle-delay 1)
  (setq which-key-special-keys nil))
#+END_SRC
* Avy
** Avy Base
 #+BEGIN_SRC emacs-lisp
    (use-package avy
      :bind* (("C-,"     . avy-pop-mark)
              ("M-j"     . avy-goto-char)
              ("M-k"     . avy-goto-word-1)
              ("M-g n"   . avy-resume)
              ("M-g w"   . avy-goto-word-1)
              ("M-g f"   . avy-goto-line)
              ("M-g l c" . avy-copy-line)
              ("M-g l m" . avy-move-line)
              ("M-g r c" . avy-copy-region)
              ("M-g r m" . avy-move-region)
              ("M-g p"   . avy-goto-paren)
              ("M-g c"   . avy-goto-conditional)
              ("M-g M-g" . avy-goto-line))
      :config
      (defun avy-goto-paren ()
        (interactive)
        (avy--generic-jump "\\s(" nil 'pre))
      (defun avy-goto-conditional ()
        (interactive)
        (avy--generic-jump "\\s(\\(if\\|cond\\|when\\|unless\\)\\b" nil 'pre))
      (setq avy-timeout-seconds 0.3)
      (setq avy-all-windows 'all-frames)
      (defun avy-action-copy-and-yank (pt)
        "Copy and yank sexp starting on PT."
        (avy-action-copy pt)
        (yank))
      (setq avy-dispatch-alist
            '((?w . avy-action-copy)
              (?k . avy-action-kill-move)
              (?K . avy-action-kill-stay)
              (?m . avy-action-mark)
              (?y . avy-action-copy-and-yank)
              (?n . avy-action-copy)
              (?b . avy-action-copy-and-yank)))
      ;; (setq avy-keys
      ;;       '(?c ?a ?s ?d ?e ?f ?h ?w ?y ?j ?k ?l ?n ?m ?v ?r ?u ?p))
    )
 #+END_SRC
** Link hint
#+BEGIN_SRC emacs-lisp
  (use-package link-hint
    :bind*
    ("M-g o" . link-hint-open-link)
    ("M-g d" . link-hint-copy-link))
#+END_SRC
** COMMENT Avy zap
 #+BEGIN_SRC emacs-lisp
 (use-package avy-zap
   :bind (
          ("M-z" . avy-zap-to-char-dwim)
          ("M-Z" . avy-zap-up-to-char-dwim)))
 #+END_SRC
** Ace popup menu
 #+BEGIN_SRC emacs-lisp
 (use-package ace-popup-menu
   :config
   (ace-popup-menu-mode 1))
 #+END_SRC
** Ace window
 #+BEGIN_SRC emacs-lisp
   (use-package ace-window
     :bind* ("C-o" . ace-window)
     :config
     (setq aw-keys '(?a ?s ?d ?f ?g ?j ?k ?l))
     (defun aw-switch-buffer (window)
       "Swift buffer in WINDOW."
       (select-window window)
       (ivy-switch-buffer))
     (setq aw-dispatch-alist
        '((?x aw-delete-window " Ace - Delete Window")
          (?m aw-swap-window " Ace - Swap Window")
          (?n aw-flip-window)
          (?c aw-split-window-fair " Ace - Split Fair Window")
          (?v aw-split-window-vert " Ace - Split Vert Window")
          (?h aw-split-window-horz " Ace - Split Horz Window")
          (?i delete-other-windows " Ace - Maximize Window")
          (?b aw-switch-buffer " Ace - Switch Buffer")
          (?o delete-other-windows)))
     (setq aw-scope 'global))
 #+END_SRC
** COMMENT Ace flyspell
 #+BEGIN_SRC emacs-lisp
 (use-package ace-flyspell)
 #+END_SRC
* Visual regexp steroids
#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :bind
  (("C-c r" . vr/replace)
   ("C-c q" . vr/query-replace)
   ;; if you use multiple-cursors, this is for you:
   ("C-c p" . vr/mc-mark))
   :config
   (use-package visual-regexp-steroids))
#+END_SRC
* Templates
** Config
#+BEGIN_SRC emacs-lisp
(auto-insert-mode)
(setq auto-insert-directory "~/.emacs.d/templates/")
(setq auto-insert-query nil)
#+END_SRC
* Latex
** Auctex package
#+BEGIN_SRC emacs-lisp
  (use-package tex
    :ensure auctex
    :diminish reftex-mode cdlatex-mode
    :mode ("\\.tex\\'" . latex-mode)
    :bind
    (:map TeX-mode-map
    ("M-q" . ales/fill-paragraph))
    :config
    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq TeX-save-query nil)
    ;; (add-hook 'LaTeX-mode-hook 'visual-line-mode) ;; makes swiper super slow
    (add-hook 'LaTeX-mode-hook 'flyspell-mode)
    (setq LaTeX-math-abbrev-prefix "~")
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
    (define-auto-insert "\\.tex$" "latex-template.tex")
    (setq reftex-plug-into-AUCTeX t)
    (setq preview-scale-function 1)
    (setq reftex-ref-macro-prompt nil)
    (setq TeX-PDF-mode t)

    (add-hook
     'LaTeX-mode-hook
     (lambda ()
       (TeX-auto-add-type "theorem" "mg-LaTeX")
       ;; Self Parsing -- see (info "(auctex)Hacking the Parser").
       (defvar mg-LaTeX-theorem-regexp
         (concat "\\\\newtheorem{\\(" TeX-token-char "+\\)}")
         "Matches new theorems.")
       (defvar mg-LaTeX-auto-theorem nil
         "Temporary for parsing theorems.")
       (defun mg-LaTeX-theorem-prepare ()
         "Clear `mg-LaTex-auto-theorem' before use."
         (setq mg-LaTeX-auto-theorem nil))
       (defun mg-LaTeX-theorem-cleanup ()
         "Move theorems from `mg-LaTeX-auto-theorem' to `mg-LaTeX-theorem-list'.
      Add theorem to the environment list with an optional argument."
         (mapcar (lambda (theorem)
                   (add-to-list 'mg-LaTeX-theorem-list (list theorem))
                   (LaTeX-add-environments
                    `(,theorem ["Name"])))
                 mg-LaTeX-auto-theorem))
       ;; FIXME: This does not seem to work unless one does a manual reparse.
       (add-hook 'TeX-auto-prepare-hook 'mg-LaTeX-theorem-prepare)
       (add-hook 'TeX-auto-cleanup-hook 'mg-LaTeX-theorem-cleanup)
       (TeX-auto-add-regexp `(,mg-LaTeX-theorem-regexp 1 mg-LaTeX-auto-theorem))))
    (add-hook 'TeX-language-dk-hook
              (lambda () (ispell-change-dictionary "dansk")))

    ;; Use Skim as viewer, enable source <-> PDF sync
    ;; make latexmk available via C-c C-c
    ;; Note: SyncTeX is setup via ~/.latexmkrc (see below)
    (add-to-list 'TeX-command-list '("latexmk" "latexmk -pdf %s" TeX-run-TeX nil t
                                     :help "Run latexmk on file"))
    (add-to-list 'TeX-command-list '("make" "make" TeX-run-TeX nil t
                                     :help "Runs make"))
    (add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk")))
    (add-hook 'TeX-mode-hook '(lambda () (setq company-minimum-prefix-length 2)))

    (defun ales/fill-paragraph (&optional P)
      "When called with prefix argument call `fill-paragraph'.
       Otherwise split the current paragraph into one sentence per line."
      (interactive "P")
      (if (not P)
          (save-excursion 
            (let ((fill-column 12345678)) ;; relies on dynamic binding
              (fill-paragraph) ;; this will not work correctly if the paragraph is
              ;; longer than 12345678 characters (in which case the
              ;; file must be at least 12MB long. This is unlikely.)
              (let ((end (save-excursion
                           (forward-paragraph 1)
                           (backward-sentence)
                           (point-marker))))  ;; remember where to stop
                (beginning-of-line)
                (while (progn (forward-sentence)
                              (<= (point) (marker-position end)))
                  (just-one-space) ;; leaves only one space, point is after it
                  (delete-char -1) ;; delete the space
                  (newline)        ;; and insert a newline
                  (LaTeX-indent-line) ;; TODO: fix-this
                  ))))
        ;; otherwise do ordinary fill paragraph
        (fill-paragraph P)))  

    ;; use Skim as default pdf viewer
    ;; Skim's displayline is used for forward search (from .tex to .pdf)
    ;; option -b highlights the current line; option -g opens Skim in the background
    (setq TeX-view-program-selection '((output-pdf "PDF Viewer")))
    (setq TeX-view-program-list
          '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")))
    (setq TeX-source-correlate-method 'synctex
          TeX-source-correlate-mode t
          TeX-source-correlate-start-server t))
#+END_SRC
** Cdlatex
#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
    :config
    (add-to-list 'cdlatex-math-modify-alist
               '(?B "\\mathbb" nil t nil nil))
    (setq cdlatex-env-alist
        '(("tikz-cd" "\\begin{tikz-cd}\n?\n\end{tikz-cd}\n" "\\\\?")
          ("tikz" "\\begin{tikz-cd}\n?\n\end{tikz}\n" "\\\\?")))
    (add-hook 'LaTeX-mode-hook 'turn-on-cdlatex)   ; with AUCTeX LaTeX mode
    (setq cdlatex-command-alist
          '(("ww" "Insert \\text{}" "\\text{?}" cdlatex-position-cursor nil nil t)
            ("bb" "Insert \\mathbb{}" "\\mathbb{?}" cdlatex-position-cursor nil nil t)
            ("lm" "Insert \\lim_{}" "\\lim_{?}" cdlatex-position-cursor nil nil t)
            ("dm" "Insert display math equation" "\\[\n?\n\\]" cdlatex-position-cursor nil t nil)
            ("equ*" "Insert equation* environment" "\\begin{equation*}\n?\n\\end{equation*}" cdlatex-position-cursor nil t nil)))
    )
#+END_SRC
* Recentf
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :config
  (setq recentf-exclude '("COMMIT_MSG" "COMMIT_EDITMSG" "github.*txt$"
                          ".*png$" ".*cache$"))
  (setq recentf-max-saved-items 5))
#+END_SRC
* Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :config
    (setq projectile-mode-line
        '(:eval (if (projectile-project-p)
                    (format " [%s]"
                            (projectile-project-name))
                  "")))
    (projectile-global-mode)
    )
#+END_SRC
* Ivy + Swiper + Counsel
** Ivy Base
 #+BEGIN_SRC emacs-lisp
    (use-package ivy
      :demand
      :diminish ivy-mode
      :ensure t
      :init
      (unbind-key "M-i")
      :bind
      (( "C-r" . ivy-resume)
       :map ivy-minibuffer-map
       ("M-y" . ivy-next-line)
       ("<return>" . ivy-alt-done)
       ("C-M-h" . ivy-previous-line-and-call)
       ("C-:" . ivy-dired)
       ("C-c o" . ivy-occur)
       )
      :config
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq ivy-height 12)
      (setq ivy-count-format "%d/%d | ")
      (setq ivy-extra-directories nil)
      (setq ivy-display-style 'fancy)
      (setq magit-completing-read-function 'ivy-completing-read)
      (setq projectile-completion-system 'ivy)
      ;; (setq ivy-switch-buffer-faces-alist
      ;;       '((emacs-lisp-mode . swiper-match-face-1)
      ;;         (dired-mode . ivy-subdir)
      ;;         (org-mode . org-level-5)))

      (defun ora-insert (x)
        (insert
         (if (stringp x)
             x
           (car x))))

      (defun ora-kill-new (x)
        (kill-new
         (if (stringp x)
             x
           (car x))))

      (ivy-set-actions
       t
       '(("i" ora-insert "insert")
         ("w" ora-kill-new "copy"))))
 #+END_SRC
** Swiper
 #+BEGIN_SRC emacs-lisp
 (use-package swiper
   :demand
   :config
   )
 #+END_SRC
** Counsel
 #+BEGIN_SRC emacs-lisp
   (use-package counsel
     :demand
     :bind
     (( "C-s" . counsel-grep-or-swiper)
      ( "M-g g" . counsel-rg)
      ( "M-i" . counsel-imenu)
      ( "M-x" . counsel-M-x)
      ( "C-x C-f" . counsel-find-file)
      ( "<f1> f" . counsel-describe-function)
      ( "<f1> v" . counsel-describe-variable)
      ( "<f1> l" . counsel-load-library)
      ( "<f2> i" . counsel-info-lookup-symbol)
      ( "<f2> u" . counsel-unicode-char)
      ( "C-h b" . counsel-descbinds)
      ( "C-c g" . counsel-git)
      ( "C-c j" . counsel-git-grep)
      ( "C-c k" . counsel-ag)
      ( "C-x l" . counsel-locate)
      ( "C-r" . ivy-resume)
      ( "C-c v" . ivy-push-view)
      ( "C-c V" . ivy-pop-view)
      ( "C-c g" . counsel-git)
      ( "C-c j" . counsel-git-grep)
      ("M-y" . counsel-yank-pop)
      :map ivy-minibuffer-map
      ("M-y" . ivy-next-line)
      )
     :config     
     (setq imenu-auto-rescan t)
     (advice-add 'counsel-grep-or-swiper :before 'avy-push-mark)
     (advice-add 'counsel-rg :before (lambda (&rest _) (xref-push-marker-stack)))        
     (setq counsel-locate-cmd 'counsel-locate-cmd-mdfind)
     (setq counsel-find-file-ignore-regexp "\\.|\\.DS_Store")
     (defun ivy-copy-to-buffer-action (x)
       (with-ivy-window
         (insert x)))
     (ivy-set-actions 'counsel-imenu
                      '(("I" ivy-copy-to-buffer-action "insert"))))
 #+END_SRC
** Flyspell Correct Ivy
 #+BEGIN_SRC emacs-lisp
   (use-package flyspell-correct-ivy
     :ensure t
     :after flyspell
     :bind (:map flyspell-mode-map
                 ("C-;" . flyspell-correct-previous-word-generic))
     :config
     )
 #+END_SRC
** Ivy hydra
 #+BEGIN_SRC emacs-lisp
 (use-package ivy-hydra)
 #+END_SRC
* Dump Jump
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :bind (;("M-g o" . dumb-jump-go-other-window)
           ("M-g j" . dumb-jump-go)
           ("M-g i" . dumb-jump-go-prompt)
           ("M-g x" . dumb-jump-go-prefer-external)
           ("M-g z" . dumb-jump-go-prefer-external-other-window))
    :config (setq dumb-jump-selector 'ivy) ;; (setq dumb-jump-selector 'helm)
    :ensure)
#+END_SRC
* COMMENT Moe theme
#+BEGIN_SRC emacs-lisp
  (use-package moe-theme
    :config
    (moe-light))
#+END_SRC
* Themes
#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-solarized)
  (use-package solarized-theme
    :init
    (setq solarized-use-variable-pitch nil
          solarized-scale-org-headlines nil))
  (use-package spacemacs-theme)

  (load-theme 'solarized-light)
#+END_SRC
* Languages
** ML
#+BEGIN_SRC emacs-lisp
(use-package sml-mode
  :mode "\\.sml\\'"
  :interpreter "sml")
#+END_SRC
** Ocaml
#+BEGIN_SRC emacs-lisp
  (load "~/.opam/system/share/emacs/site-lisp/tuareg-site-file")
  (let ((opam-share (ignore-errors (car (process-lines "opam" "config" "var" "share")))))
    (when (and opam-share (file-directory-p opam-share))
      ;; Register Merlin
      (add-to-list 'load-path (expand-file-name "emacs/site-lisp" opam-share))
      (autoload 'merlin-mode "merlin" nil t nil)
      ;; Automatically start it in OCaml buffers
      (add-hook 'tuareg-mode-hook 'merlin-mode t)
      (add-hook 'caml-mode-hook 'merlin-mode t)
      ;; Use opam switch to lookup ocamlmerlin binary
      (setq merlin-command 'opam)))
  ;; (dolist
  ;;     (var (car (read-from-string
  ;; 	       (shell-command-to-string "opam config env --sexp"))))
  ;;   (setenv (car var) (cadr var)))
  ;; Update the emacs path
  ;; (setq exec-path (split-string (getenv "PATH") path-separator))
  ;; Update the emacs load path
  ;; (push (concat (getenv "OCAML_TOPLEVEL_PATH")
  ;; 	      "/../../share/emacs/site-lisp") load-path)
  ;; Automatically load utop.el
  (autoload 'utop "utop" "Toplevel for OCaml" t)
  (autoload 'utop-minor-mode "utop" "Minor mode for utop" t)
  (add-hook 'tuareg-mode-hook 'utop-minor-mode)
#+END_SRC
** Scheme
#+BEGIN_SRC emacs-lisp
  (setq scheme-program-name "petite")
  (defun scheme-send-buffer-and-go ()
    "Send entire content of the buffer to the Inferior Scheme process\
     and goto the Inferior Scheme buffer."
    (interactive)
    (scheme-send-region-and-go (point-min) (point-max)))
  ;; Configuration run when scheme-mode is loaded
  (add-hook 'scheme-mode-hook
            (lambda ()
              ;; indent with spaces
              (setq indent-tabs-mode nil)
              (setq-local comment-start ";;; ")
              ;; Danvy-style key bindings
              (local-set-key (kbd "C-c d")   'scheme-send-definition-and-go)
              (local-set-key (kbd "C-c C-b") 'scheme-send-buffer-and-go)
              ;; fix indentation of some special forms
              (put 'cond   'scheme-indent-hook 0)
              (put 'guard  'scheme-indent-hook 1)
              (put 'when   'scheme-indent-hook 1)
              (put 'unless 'scheme-indent-hook 1)
              ;; special forms from Petite Chez Scheme
              (put 'trace-lambda  'scheme-indent-hook 2)
              (put 'extend-syntax 'scheme-indent-hook 1)
              (put 'with          'scheme-indent-hook 0)
              (put 'parameterize  'scheme-indent-hook 0)
              (put 'define-syntax 'scheme-indent-hook 1)
              (put 'syntax-case   'scheme-indent-hook 0)
              ;; special forms for Schelog
              (put '%rel   'scheme-indent-hook 1)
              (put '%which 'scheme-indent-hook 1)
              ))

  ;; (defun my-pretty-lambda ()
  ;;   "make some word or string show as pretty Unicode symbols"
  ;;   (setq prettify-symbols-alist
  ;;         '(
  ;;           ("lambda" . 955) ; λ
  ;;           ))
  ;;   (prettify-symbols-mode 1))
  ;; (add-hook 'scheme-mode-hook 'my-pretty-lambda)

  (add-hook 'inferior-scheme-mode-hook
            (lambda ()
              ;; Overwrite the standard 'switch-to-buffer' to use
              ;; 'switch-to-buffer-other-window'
              (defun switch-to-scheme (eob-p)
                "Switch to the scheme process buffer.
       With argument, position cursor at end of buffer."
                (interactive "P")
                (if (or (and scheme-buffer (get-buffer scheme-buffer))
                        (scheme-interactively-start-process))
                    (switch-to-buffer-other-window scheme-buffer)
                  (error "No current process buffer.  See variable `scheme-buffer'"))
                (when eob-p
                  (push-mark)
                  (goto-char (point-max))))))

  (setq auto-mode-alist
        (append '(("\\.ss$" . scheme-mode)
                  ("\\.scm$" . scheme-mode)
                  ("\\.sim$" . scheme-mode))
                auto-mode-alist))
  (setenv "TEXINPUTS" (concat "~/.latex/scheme-listings/:" (getenv "TEXINPUTS")))
#+END_SRC
** Coq
#+BEGIN_SRC emacs-lisp
  (require 'proof-site "~/.emacs.d/lisp/PG/generic/proof-site")
  (eval-after-load "proof-script"
    '(progn
       (define-key proof-mode-map [(meta n)] 
         'proof-assert-next-command-interactive)
       (define-key proof-mode-map [(meta b)] 
         'proof-undo-last-successful-command)
       ))
  (use-package company-coq
    :config
    (add-hook 'coq-mode-hook #'company-coq-mode))
  (setq proof-three-window-mode-policy 'hybrid)
  (setq proof-script-fly-past-comments t)

  (with-eval-after-load 'coq  
    ;; Small convenience for commonly written commands.
    (define-key coq-mode-map "\C-c\C-m" "\nend\t")
    (define-key coq-mode-map "\C-c\C-e"
      #'endless/qed)
    (defun endless/qed ()
      (interactive)
      (unless (memq (char-before) '(?\s ?\n ?\r))
        (insert " "))
      (insert "Qed.")
      (proof-assert-next-command-interactive)))
  (define-abbrev-table 'coq-mode-abbrev-table '())
  ;;(define-abbrev coq-mode-abbrev-table "re" "reflexivity.")
  ;;(define-abbrev coq-mode-abbrev-table "id" "induction")
  ;;(define-abbrev coq-mode-abbrev-table "si" "simpl.")
  ;;(advice-add 'proof-assert-next-command-interactive
  ;;            :before #'expand-abbrev)
  ;;(defun open-after-coq-command ()
  ;;  (when (looking-at-p " *(\\*")
  ;;    (open-line 1)))
  ;;(advice-add 'proof-assert-next-command-interactive
  ;;            :after #'open-after-coq-command)
#+END_SRC
** Scala
#+BEGIN_SRC emacs-lisp
  (use-package ensime
    :config
    (setq ensime-startup-notification nil))
  (use-package scala-mode
    :interpreter
    ("scala" . scala-mode))
#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp
    (use-package haskell-mode
      :mode "\\.hs\\'"
      :config
      (let ((my-cabal-path (expand-file-name "~/.cabal/bin")))
        (setenv "PATH" (concat my-cabal-path path-separator (getenv "PATH")))
        (add-to-list 'exec-path my-cabal-path))
      (custom-set-variables '(haskell-tags-on-save t))

      (add-hook 'haskell-mode-hook
                (lambda ()
                  (set (make-local-variable 'company-backends)
                       (append '((company-capf company-dabbrev-code))
                               company-backends))))

      (setq
       haskell-process-suggest-remove-import-lines t
       haskell-process-auto-import-loaded-modules t
       haskell-process-log t)

      (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
      (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
      (define-key haskell-mode-map (kbd "C-c C-n C-t") 'haskell-process-do-type)
      (define-key haskell-mode-map (kbd "C-c C-n C-i") 'haskell-process-do-info)
      (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-cabal-build)
      (define-key haskell-mode-map (kbd "C-c C-n c") 'haskell-process-cabal)

      (define-key haskell-cabal-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
      (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
      (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
      (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)
    )
#+END_SRC
** Markdown
#+BEGIN_SRC emacs-lisp
    (use-package markdown-mode
      :ensure t
      :commands (markdown-mode gfm-mode)
      :mode (("README\\.md\\'" . gfm-mode)
             ("\\.md\\'" . markdown-mode)
             ("\\.txt\\'" . markdown-mode)
             ("\\.markdown\\'" . markdown-mode))
      :init
      (setq markdown-command "multimarkdown")
      :config
      (add-hook 'markdown-mode-hook 'flyspell-mode))

#+END_SRC
** F*
#+BEGIN_SRC emacs-lisp
  (use-package fstar-mode
    :mode (("\\.fst\\')" . fstar-mode))) 
#+END_SRC
* Private configuration
#+BEGIN_SRC emacs-lisp
  (let ((private-file (concat user-emacs-directory "private.org")))
  (when (file-exists-p private-file)
  (progn
  (org-babel-tangle-file private-file)
  (load-file (concat user-emacs-directory "private.el")))))
#+END_SRC
